from flask import Flask, request, jsonify
from flask_cors import CORS
import time

app = Flask(__name__)
CORS(app)  # Enable CORS for frontend integration

# ============================================================================
# IN-MEMORY STORAGE (For demonstration purposes)
# ============================================================================
# In a production app, these would be replaced with:
# - PostgreSQL/MySQL for submissions data
# - Redis for deduplication tracking
# - Cloud storage (S3/GCS) for images
# ============================================================================

# Set to track submission IDs that have already been processed
# This is the core of our deduplication mechanism
# Each submission gets a unique UUID from the frontend
received_ids = set()

# List to store all successfully processed submissions
submissions = []

import os
import json

# Directory where uploaded crop images will be stored
UPLOAD_FOLDER = 'backend/uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

@app.route('/api/sync', methods=['POST'])
def sync_data():
    """
    Main sync endpoint that receives crop disease submissions from the frontend.
    
    Supports two types of requests:
    1. Multipart/form-data - For submissions WITH crop images
    2. JSON - For submissions WITHOUT images (legacy/text-only)
    
    Key Features:
    - Deduplication: Prevents the same submission from being processed twice
    - Image storage: Saves crop images to disk with unique filenames
    - Status tracking: Returns "diagnosis_pending" status for all submissions
    
    Deduplication Strategy:
    - Each submission has a unique UUID generated by the frontend
    - The backend tracks all received UUIDs in the 'received_ids' set
    - If a UUID is seen again (e.g., due to network retry), it's skipped
    """
    
    # ========================================================================
    # DEBUG LOGGING - Helps troubleshoot request type detection issues
    # ========================================================================
    print("\n" + "="*60)
    print("üîç INCOMING REQUEST DEBUG")
    print("="*60)
    print(f"Content-Type: {request.content_type}")
    print(f"Method: {request.method}")
    print(f"is_json: {request.is_json}")
    print(f"Files keys: {list(request.files.keys())}")
    print(f"Form keys: {list(request.form.keys())}")
    print(f"Has 'image' in files: {'image' in request.files}")
    print(f"Content-Type contains 'multipart': {'multipart' in str(request.content_type).lower()}")
    print("="*60 + "\n")
    
    # ========================================================================
    # BRANCH 1: Handle Multipart/Form-Data Requests (WITH Images)
    # ========================================================================
    # When the frontend sends an image, it uses FormData which results in
    # Content-Type: multipart/form-data
    # The request contains:
    # - 'image' file: The actual crop photo (Blob/File)
    # - 'submission' form field: JSON string with metadata (id, data, etc.)
    # ========================================================================
    if 'image' in request.files or 'multipart' in str(request.content_type).lower():
        print("üñºÔ∏è [BACKEND] Detected multipart/form-data request")
        
        # Validate that the image file is present
        if 'image' not in request.files:
            print("‚ö†Ô∏è [BACKEND] Multipart request but no image file found")
            return jsonify({"status": "error", "message": "No image file in multipart request"}), 400
        
        file = request.files['image']
        
        # Extract the submission metadata from the form data
        # The frontend sends this as a JSON string in the 'submission' field
        submission_json = request.form.get('submission')
        
        if not submission_json:
            print("‚ö†Ô∏è [BACKEND] No submission metadata found in form data")
            return jsonify({"status": "error", "message": "Missing submission metadata"}), 400
        
        # Parse the JSON metadata
        try:
            sub = json.loads(submission_json)
        except json.JSONDecodeError as e:
            print(f"‚ùå [BACKEND] Failed to parse submission JSON: {e}")
            return jsonify({"status": "error", "message": "Invalid JSON in submission metadata"}), 400
            
        # Extract the unique submission ID (UUID from frontend)
        sub_id = sub.get('id')
        
        # ====================================================================
        # SAVE THE IMAGE FILE TO DISK
        # ====================================================================
        # Images are saved with the submission ID as the filename
        # This makes it easy to link images to submissions later
        # ====================================================================
        if file and sub_id:
            # Preserve the original file extension (jpg, png, etc.)
            file_ext = file.filename.split('.')[-1] if '.' in file.filename else 'jpg'
            filename = f"{sub_id}.{file_ext}"
            filepath = os.path.join(UPLOAD_FOLDER, filename)
            file.save(filepath)
            print(f"‚úÖ [BACKEND] Image saved: {filename} ({file.content_length} bytes)")
        
        # ====================================================================
        # DEDUPLICATION CHECK
        # ====================================================================
        # Check if we've already processed this submission ID
        # This prevents duplicate processing if:
        # - Network retry sends the same request twice
        # - User accidentally clicks submit multiple times
        # - Offline sync queue retries the same submission
        # ====================================================================
        if sub_id in received_ids:
             print(f"‚ö†Ô∏è [DEDUPE] Skipped duplicate submission: {sub_id}")
        else:
            # First time seeing this ID - process it!
            received_ids.add(sub_id)  # Mark as received
            sub['received_at'] = time.time()  # Add server timestamp
            sub['server_status'] = "diagnosis_pending"  # Set status
            sub['has_image'] = True  # Flag that this submission has an image
            submissions.append(sub)  # Store in our "database"
            print(f"‚úÖ [RECV] New submission with image: {sub_id}")
            
        return jsonify({
            "status": "success",
            "message": "Image and data synced. Diagnosis pending."
        }), 200

    # ========================================================================
    # BRANCH 2: Handle Standard JSON Requests (WITHOUT Images)
    # ========================================================================
    # This is the legacy path for text-only submissions
    # Used when the frontend sends data without an image
    # Content-Type: application/json
    # Request body contains an array of submissions
    # ========================================================================
    elif request.is_json:
        print("üìù [BACKEND] Detected JSON request")
        data = request.json
        incoming_submissions = data.get('submissions', [])
        
        processed_count = 0
        skipped_count = 0
        
        # Process each submission in the batch
        for sub in incoming_submissions:
            sub_id = sub.get('id')
            if not sub_id: continue
                
            # ================================================================
            # DEDUPLICATION CHECK (Same logic as multipart branch)
            # ================================================================
            if sub_id in received_ids:
                skipped_count += 1
                print(f"[DEDUPE] Skipped duplicate submission: {sub_id}")
                continue
                
            # First time seeing this ID - process it!
            received_ids.add(sub_id)  # Mark as received
            sub['received_at'] = time.time()  # Add server timestamp
            sub['server_status'] = "diagnosis_pending"  # Set status
            submissions.append(sub)  # Store in our "database"
            processed_count += 1
            print(f"[RECV] New submission: {sub_id}")

        response = {
            "status": "success",
            "processed": processed_count,
            "skipped": skipped_count,
            "message": "Data synced successfully. Diagnosis is pending."
        }
        return jsonify(response), 200
    
    # ========================================================================
    # ERROR HANDLING: Unsupported Content Type
    # ========================================================================
    # If we reach here, the request is neither multipart nor JSON
    # This shouldn't happen with a properly configured frontend
    # ========================================================================
    print(f"‚ùå DEBUG: Failed to match request type. Type: {request.content_type}")
    print(f"DEBUG: is_json: {request.is_json}")
    print(f"DEBUG: files keys: {list(request.files.keys())}")
    print(f"DEBUG: form keys: {list(request.form.keys())}")
    
    return jsonify({
        "error": f"Unsupported Media Type. Received: {request.content_type}, Files: {list(request.files.keys())}, Form: {list(request.form.keys())}"
    }), 415

@app.route('/api/submissions', methods=['GET'])
def get_submissions():
    """Debug endpoint to see what we have stored."""
    return jsonify(submissions), 200

if __name__ == '__main__':
    print("Starting Offline Sync Backend on port 5000...")
    app.run(debug=True, port=5000)
